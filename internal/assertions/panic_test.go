// SPDX-FileCopyrightText: Copyright 2025 go-swagger maintainers
// SPDX-License-Identifier: Apache-2.0

package assertions

import (
	"errors"
	"io"
	"testing"
)

func TestPanicDidPanic(t *testing.T) {
	t.Parallel()

	const panicMsg = "Panic!"

	if funcDidPanic, msg, _ := didPanic(func() {
		panic(panicMsg)
	}); !funcDidPanic || msg != panicMsg {
		t.Error("didPanic should return true, panicMsg")
	}

	{
		funcDidPanic, msg, _ := didPanic(func() {
			err := errors.New("test")
			panic(err) // nil is no longer supported as a panic value and returns a runtime.PanicNil error
		})
		if !funcDidPanic {
			t.Error("didPanic should have panicked")
		}
		if msg == nil {
			t.Errorf("didPanic should have returned something, but got nil")
		}
	}

	if funcDidPanic, _, _ := didPanic(func() {
	}); funcDidPanic {
		t.Error("didPanic should return false")
	}
}

func TestPanics(t *testing.T) {
	t.Parallel()
	mock := new(testing.T)

	if !Panics(mock, func() {
		panic("Panic!")
	}) {
		t.Error("Panics should return true")
	}

	if Panics(mock, func() {
	}) {
		t.Error("Panics should return false")
	}
}

func TestPanicsWithValue(t *testing.T) {
	t.Parallel()
	mock := new(testing.T)

	if !PanicsWithValue(mock, "Panic!", func() {
		panic("Panic!")
	}) {
		t.Error("PanicsWithValue should return true")
	}

	{
		err := errors.New("test")
		if !PanicsWithValue(mock, err, func() {
			panic(err) // panic no longer supports a nil argument
		}) {
			t.Error("PanicsWithValue should return true")
		}
	}

	if PanicsWithValue(mock, "Panic!", func() {
	}) {
		t.Error("PanicsWithValue should return false")
	}

	if PanicsWithValue(mock, "at the disco", func() {
		panic("Panic!")
	}) {
		t.Error("PanicsWithValue should return false")
	}
}

func TestPanicsWithError(t *testing.T) {
	t.Parallel()

	mock := new(captureT)
	succeeded := PanicsWithError(mock, "panic", func() {
		panic(errors.New("panic"))
	})
	mock.checkResultAndErrMsg(t, true, succeeded, "")

	succeeded = PanicsWithError(mock, "Panic!", func() {})
	Equal(t, false, succeeded, "PanicsWithError should return false")
	Contains(t, mock.msg, "Panic value:\t<nil>")

	succeeded = PanicsWithError(mock, "expected panic err msg", func() {
		panic(errors.New("actual panic err msg"))
	})
	Equal(t, false, succeeded, "PanicsWithError should return false")
	Contains(t, mock.msg, `Error message:	"actual panic err msg"`)

	succeeded = PanicsWithError(mock, "expected panic err msg", func() {
		panic(&PanicsWrapperError{"wrapped", errors.New("actual panic err msg")})
	})
	Equal(t, false, succeeded, "PanicsWithError should return false")
	Contains(t, mock.msg, `Error message:	"wrapped: actual panic err msg"`)

	succeeded = PanicsWithError(mock, "expected panic msg", func() {
		panic("actual panic msg")
	})
	Equal(t, false, succeeded, "PanicsWithError should return false")
	Contains(t, mock.msg, `Panic value:	"actual panic msg"`)
	NotContains(t, mock.msg, "Error message:", "PanicsWithError should not report error message if not due an error")
}

func TestPanicNotPanics(t *testing.T) {
	t.Parallel()
	mock := new(testing.T)

	if !NotPanics(mock, func() {
	}) {
		t.Error("NotPanics should return true")
	}

	if NotPanics(mock, func() {
		panic("Panic!")
	}) {
		t.Error("NotPanics should return false")
	}
}

func TestPanicCallerInfoWithAutogeneratedFunctions(t *testing.T) {
	t.Parallel()

	NotPanics(t, func() {
		testAutogeneratedFunction()
	})
}

type PanicsWrapperError struct {
	Prefix string
	Err    error
}

func (e PanicsWrapperError) Error() string {
	return e.Prefix + ": " + e.Err.Error()
}

func testAutogeneratedFunction() {
	defer func() {
		if err := recover(); err == nil {
			panic("did not panic")
		}
		CallerInfo()
	}()
	t := struct {
		io.Closer
	}{}
	c := t
	c.Close()
}
